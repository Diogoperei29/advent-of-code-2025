/*
 * Advent of Code 2025 - All Solutions Runner
 * 
 * This file contains all day classes and runs all solutions in sequence.
 * 
 * Usage:
 *   solver_all.exe                              - Run all solutions
 *   solver_all.exe --benchmark                  - Run all solutions + benchmarks
 *   solver_all.exe --benchmark --benchmark_filter="Day3"  - Run solutions + filtered benchmarks
 * 
 * Note: To add your solution for a specific day:
 *   1. Implement the part1() and part2() methods in the corresponding DayN class below
 *   2. Also update the same class in the respective N/solve.cpp file
 *   3. The solver_all.cpp and individual solve.cpp files are independent copies
 */

#include <benchmark/benchmark.h>
#include <iostream>
#include <string>
#include <sstream>
#include <chrono>
#include <iomanip>

// Day 1
class Day1 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 2
class Day2 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 3
class Day3 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 4
class Day4 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 5
class Day5 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 6
class Day6 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 7
class Day7 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 8
class Day8 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 9
class Day9 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 10
class Day10 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 11
class Day11 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Day 12
class Day12 {
public:
    std::string part1() {
        // TODO: Implement part 1 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }

    std::string part2() {
        // TODO: Implement part 2 solution
        // For numeric results: return std::to_string(result);
        // For other types: use std::ostringstream or std::format (C++20)
        return "Not implemented";
    }
};

// Helper function to run a day's solution
template<typename DayClass>
void runDay(int dayNumber) {
    DayClass solver;
    
    std::cout << "=== Day " << std::setw(2) << dayNumber << " ===" << std::endl;
    
    auto start1 = std::chrono::high_resolution_clock::now();
    std::string result1 = solver.part1();
    auto end1 = std::chrono::high_resolution_clock::now();
    auto duration1 = std::chrono::duration_cast<std::chrono::microseconds>(end1 - start1);
    
    std::cout << "  Part 1: " << result1 
              << " (" << duration1.count() << " μs)" << std::endl;
    
    auto start2 = std::chrono::high_resolution_clock::now();
    std::string result2 = solver.part2();
    auto end2 = std::chrono::high_resolution_clock::now();
    auto duration2 = std::chrono::duration_cast<std::chrono::microseconds>(end2 - start2);
    
    std::cout << "  Part 2: " << result2 
              << " (" << duration2.count() << " μs)" << std::endl;
    std::cout << std::endl;
}

// Benchmarks for all days
static void BM_Day1_Part1(benchmark::State& state) {
    Day1 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day1_Part1)->Iterations(1);

static void BM_Day1_Part2(benchmark::State& state) {
    Day1 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day1_Part2)->Iterations(1);

static void BM_Day2_Part1(benchmark::State& state) {
    Day2 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day2_Part1)->Iterations(1);

static void BM_Day2_Part2(benchmark::State& state) {
    Day2 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day2_Part2)->Iterations(1);

static void BM_Day3_Part1(benchmark::State& state) {
    Day3 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day3_Part1)->Iterations(1);

static void BM_Day3_Part2(benchmark::State& state) {
    Day3 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day3_Part2)->Iterations(1);

static void BM_Day4_Part1(benchmark::State& state) {
    Day4 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day4_Part1)->Iterations(1);

static void BM_Day4_Part2(benchmark::State& state) {
    Day4 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day4_Part2)->Iterations(1);

static void BM_Day5_Part1(benchmark::State& state) {
    Day5 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day5_Part1)->Iterations(1);

static void BM_Day5_Part2(benchmark::State& state) {
    Day5 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day5_Part2)->Iterations(1);

static void BM_Day6_Part1(benchmark::State& state) {
    Day6 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day6_Part1)->Iterations(1);

static void BM_Day6_Part2(benchmark::State& state) {
    Day6 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day6_Part2)->Iterations(1);

static void BM_Day7_Part1(benchmark::State& state) {
    Day7 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day7_Part1)->Iterations(1);

static void BM_Day7_Part2(benchmark::State& state) {
    Day7 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day7_Part2)->Iterations(1);

static void BM_Day8_Part1(benchmark::State& state) {
    Day8 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day8_Part1)->Iterations(1);

static void BM_Day8_Part2(benchmark::State& state) {
    Day8 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day8_Part2)->Iterations(1);

static void BM_Day9_Part1(benchmark::State& state) {
    Day9 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day9_Part1)->Iterations(1);

static void BM_Day9_Part2(benchmark::State& state) {
    Day9 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day9_Part2)->Iterations(1);

static void BM_Day10_Part1(benchmark::State& state) {
    Day10 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day10_Part1)->Iterations(1);

static void BM_Day10_Part2(benchmark::State& state) {
    Day10 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day10_Part2)->Iterations(1);

static void BM_Day11_Part1(benchmark::State& state) {
    Day11 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day11_Part1)->Iterations(1);

static void BM_Day11_Part2(benchmark::State& state) {
    Day11 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day11_Part2)->Iterations(1);

static void BM_Day12_Part1(benchmark::State& state) {
    Day12 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part1());
    }
}
BENCHMARK(BM_Day12_Part1)->Iterations(1);

static void BM_Day12_Part2(benchmark::State& state) {
    Day12 solver;
    for (auto _ : state) {
        benchmark::DoNotOptimize(solver.part2());
    }
}
BENCHMARK(BM_Day12_Part2)->Iterations(1);

int main(int argc, char** argv) {
    std::cout << "╔════════════════════════════════════════════╗" << std::endl;
    std::cout << "║   Advent of Code 2025 - All Solutions   ║" << std::endl;
    std::cout << "╚════════════════════════════════════════════╝" << std::endl;
    std::cout << std::endl;
    
    auto totalStart = std::chrono::high_resolution_clock::now();
    
    runDay<Day1>(1);
    runDay<Day2>(2);
    runDay<Day3>(3);
    runDay<Day4>(4);
    runDay<Day5>(5);
    runDay<Day6>(6);
    runDay<Day7>(7);
    runDay<Day8>(8);
    runDay<Day9>(9);
    runDay<Day10>(10);
    runDay<Day11>(11);
    runDay<Day12>(12);
    
    auto totalEnd = std::chrono::high_resolution_clock::now();
    auto totalDuration = std::chrono::duration_cast<std::chrono::milliseconds>(totalEnd - totalStart);
    
    std::cout << "════════════════════════════════════════════" << std::endl;
    std::cout << "Total execution time: " << totalDuration.count() << " ms" << std::endl;
    std::cout << std::endl;
    
    // Check if benchmarks should be run
    bool runBenchmarks = false;
    for (int i = 1; i < argc; ++i) {
        if (std::string(argv[i]).find("benchmark") != std::string::npos) {
            runBenchmarks = true;
            break;
        }
    }
    
    // Run benchmarks if requested
    if (runBenchmarks) {
        std::cout << "Running benchmarks..." << std::endl;
        std::cout << std::endl;
        
        // Remove --benchmark flag and pass remaining args to google benchmark
        char* newArgv[32];
        int newArgc = 0;
        newArgv[newArgc++] = argv[0];
        
        for (int i = 1; i < argc && newArgc < 31; ++i) {
            if (std::string(argv[i]) != "--benchmark") {
                newArgv[newArgc++] = argv[i];
            }
        }
        
        benchmark::Initialize(&newArgc, newArgv);
        benchmark::RunSpecifiedBenchmarks();
    }
    
    return 0;
}
